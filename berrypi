#!/usr/bin/env python
'''
The main program that should be run from a command line

  $ berrypi (options)

See

  $ berrypi -h

for details.
'''

from __future__ import print_function # Python 2 & 3 compatible print function
import os, os.path
import sys, shutil, getopt
import time
import json
import subprocess
from decimal import Decimal
import numpy # math library
import re
import functools # needed for functools.reduce()

import errorCheck as b_PyError
import parsing as b_PyParse
import submoduleProcess as b_PySubProcess
import calculations as b_PyCalc

import config; from config import BERRY_DEFAULT_CONSOLE_PREFIX as DEFAULT_PREFIX
import mmn2pathphase
import testerror; from testerror import testerror
import rmerror; from rmerror import rmerror


class Logger(object): # redirect stdout to case.outputberry file and console
    def __init__(self):
        self.terminal = sys.stdout
        # case mane is taken from structure_name
        outputFileName = structure_name + '.outputberry'
        self.log = open(outputFileName, "w")
        print("Output will also be written in " + outputFileName)

    def write(self, message):
        self.terminal.write(message)
        self.log.write(message)  

    def flush(self):
        #this flush method is needed for python 3 compatibility.
        #this handles the flush command by doing nothing.
        #you might want to specify some extra behavior here.
        pass    

def changeToWorkingDirectory(path):
    os.chdir(path)

def postProcBerryPhase(configFile, phasesRaw, spCalc):
    '''
    Pass a config file to it in order to perform the final calculation
    on the simulation. Returns the main calculation as the class object
    '''
    #set up path, case name, file extensions
    structurePath = configFile['Structure Path']
    changeToWorkingDirectory(configFile['Structure Path'])
    structName = configFile['Structure Name']
    print(DEFAULT_PREFIX + "Performing main calculation on " + structName)
    structFileExtensions = {
        'struct' : '.struct',
        'scf2' : '.scf2',
        'inc' : '.inc',
        }

    #perform the main calculation
    mainCalculation = b_PyCalc.MainCalculationContainer(
        phases = phasesRaw,
        sp = spCalc,
        orb = orbCalc,
        so = soCalc,
        kmesh = configFile['K-Mesh Divisions'],
        file_struct = structName + structFileExtensions['struct'],
        file_inc = structName + structFileExtensions['inc'],
        file_scf = structName + structFileExtensions['scf2'],
        );
    finalPolarizationValue = mainCalculation()
    return mainCalculation
        

def rawBerryPhase(configFile):
    '''
    Runs the automation process. When a command fails, returns False,
    otherwise it returns True. This allows for several automation
    processes to be batched.
    '''
    print(DEFAULT_PREFIX + \
      "Starting BerryPI for", configFile['Structure Name'] )

    # get calculation parameters and options
    runLAPW = configFile['Perform LAPW']

    # get bands
    bands = configFile['Bloch Band']
    
    #get the starting directory and switch to it
    oldCurrentWorkingDirectory = os.getcwd()
    newWorkingDirectory = configFile['Structure Path']
    changeToWorkingDirectory(newWorkingDirectory)

    #ensure background env is also in the right directory
    os.system('cd ' + newWorkingDirectory)
    print(DEFAULT_PREFIX + 'New working directory: ' + newWorkingDirectory)

    # setup wien2k, berrypi path and python path
    w2kpath = os.getenv('WIENROOT')
    if w2kpath == None:
        print(DEFAULT_PREFIX + 'ERROR: Unable to find the WIENROOT enviroment variable')
        print('             check the existance by executing "echo $WIENROOT"')
        print('             or set it up by "export WIENROOT=/path/to/wien2k"')
        sys.exit(2)
    else:
        print(DEFAULT_PREFIX + 'w2kpath = ' + w2kpath)
    pypath = sys.executable # get that to python
    print(DEFAULT_PREFIX + 'pypath = ' + pypath)
    # check python version
    if sys.version_info[0] > 2: # major python version 3 is not supported
        print(DEFAULT_PREFIX + 'WARNING: compatibility with python 3.X was only recently',
            'implemented. Proceed with caution. WloopPHI.py does not support python3.X')
    elif sys.version_info[0] == 2 and sys.version_info[1] < 7:
        print(DEFAULT_PREFIX + 'WARNING: python 2.7.X is recommended' + \
            'prior versions are not tested')
    else:
        print(DEFAULT_PREFIX, 'This python version was tested', \
            'and should be supported')
    print(DEFAULT_PREFIX, 'python major version =', sys.version_info[0])
    print(DEFAULT_PREFIX, 'python minor version =', sys.version_info[1])
    print(DEFAULT_PREFIX, 'python micro version =', sys.version_info[2])
        
    bppath = w2kpath + "/SRC_BerryPI/BerryPI"
    if not os.path.isdir(bppath): # check if BerryPI directory exists
        print(DEFAULT_PREFIX, 'bppath =', bppath)
        print(DEFAULT_PREFIX, 'ERROR: BerryPI directory does not exist')
        sys.exit(2)
    else:
        print(DEFAULT_PREFIX, 'bppath =', bppath)


    # print version
    with open(bppath+'/version.info', 'r') as versionFile: # open version file
        print(DEFAULT_PREFIX + versionFile.read())
    print(DEFAULT_PREFIX + "Python version: " + sys.version)
    print(DEFAULT_PREFIX + "Numpy version: " + numpy.version.version)
    
    #check to make sure certain files exist
    structureName = configFile['Structure Name']
    print(DEFAULT_PREFIX + "Checking prerequisite files for " + structureName)
    if not wCalc: # any calculation except for Weyl points/Wilson loop
        structFileExtensions = {
            'struct' : '.struct',
            'inc' : '.inc'
            }
    else: # case.scf2 and case.inc files are not needed for Weyl points/Wilson loop
        structFileExtensions = {
            'struct' : '.struct',
            }
    for extension in structFileExtensions.values():
        tempFilename = structureName + extension
        #TODO change to a logging system
        print(DEFAULT_PREFIX + "Checking existance of",tempFilename)
        if not b_PyError.fileExists(tempFilename):
            print( DEFAULT_PREFIX + "{} does not exist, cannot finish calculation").format(tempFilename)
            exit(2)
        else: print(DEFAULT_PREFIX + '-- OK')


    ######################################
    # copy structure file                #
    # cp $filename.struct $filename.ksym #
    ######################################
    fileNameSrc = structureName + '.struct'
    fileNameDest = structureName + '.ksym'
    shutil.copy(fileNameSrc, fileNameDest)
    print(DEFAULT_PREFIX + "Copied " + fileNameSrc + " to " + fileNameDest)


    ################
    # execute kgen #
    ################
    if runLAPW and not wCalc:
        #get our input parameters from the configuration file
        numKpoints = configFile['Number of K-Points']
        numKDivisions = configFile['K-Mesh Divisions']
        kShift = configFile['K-Mesh Shift']
        #input is a string per line representation of each input for that particular file
        inputListing = [str(numKpoints),
                        functools.reduce(lambda i,j: str(i) + ' ' + str(j), numKDivisions),
                        kShift,
                        ]
        shell_x_kgen = b_PySubProcess.VirtualShellInstance(
            'x', 'kgen', '-fbz',
            input=inputListing,
            ) # -fbz forces full BZ mesh
        try:
            shell_x_kgen.run()
        except subprocess.CalledProcessError as err:
            print(DEFAULT_PREFIX + "ERROR: in automation of " + str(structureName))
            print(DEFAULT_PREFIX + "ERROR --> " + shell_x_kgen.getCommandString())
            print(str(err))
            return False
    elif not runLAPW:
        print(DEFAULT_PREFIX + "Skip k-mesh generation, since you "+ \
            "opted for not performing LAPW.\n Proceed assuming that " + \
            "the proper k-mesh generated in the FULL BZ and vector "+ \
            "files were created in the previous run")
        print(DEFAULT_PREFIX + "k-mesh will be read from case.klist file")
        f = open( str(structureName)+'.klist' , 'r' )
        for line in f:
            kmesh = re.findall( r'\(.*?\)' , line )
            kmesh2 = re.findall( r'\d+' , kmesh[0] )
            numKDivisions = map(int, kmesh2)
            print(DEFAULT_PREFIX + "The following k-mesh will be used:", \
                numKDivisions)
            break
        f.close()


    ####################################
    # get length of k-path (-w option) #
    ####################################
    if wCalc:
        numKDivisions = [0]*3; # creale list [0,0,0]
        print(DEFAULT_PREFIX + "k-path will be read from case.klist file")
        f = open( str(structureName)+'.klist' , 'r' )
        word = ("END", "end")
        numKDivisions[0] = 0
        numKDivisions[1] = 1
        numKDivisions[2] = 1
        for line in f:
            if any(s in line for s in word): # check if end of list
                break
            numKDivisions[0] += 1
        f.close()
        print(DEFAULT_PREFIX + "The following k-path length will be used:", \
            numKDivisions)


    ##########################################
    # cp $filename.klist $filename.klist_w90 #
    ##########################################
    shell_pathphase_y_copy = b_PySubProcess.VirtualShellInstance(
        'cp',
        str(structureName)+'.klist',
        str(structureName)+'.klist_w90',
        )
    try:
        shell_pathphase_y_copy()
    except subprocess.CalledProcessError as err:
        print(DEFAULT_PREFIX + "ERROR: in automation of " + \
            str(structureName))
        print(DEFAULT_PREFIX + "ERROR --> " + \
            shell_pathphase_y_copy.getCommandString())
        print(str(err))
        return False


    #############################################################
    # Fake spin-polarized calculation if spin-orbit coupling is #
    # activated without spin polarization                       #
    # cp $filename.vsp $filename.vsp[up/dn]                     #
    # cp $filename.vns $filename.vns[up/dn]                     #
    #############################################################
    if soCalc and not spCalc:
        print(DEFAULT_PREFIX + "Faking spin-polarized calculation...")
        for ext in ['.vsp', '.vns']:
            for spin in ['up', 'dn']:
                shell_pathphase_y_copy = \
                    b_PySubProcess.VirtualShellInstance(
                    'cp',
                    str(structureName) + ext,
                    str(structureName) + ext + spin,
                    );
                try:
                    shell_pathphase_y_copy()
                except subprocess.CalledProcessError as err:
                    print(DEFAULT_PREFIX + "ERROR: in automation of " + \
                        str(structureName))
                    print(DEFAULT_PREFIX + "ERROR --> " + \
                        shell_pathphase_y_copy.getCommandString())
                    print(str(err))
                    return False


    ##################
    # Parallel mode? #
    ##################
    if pCalc:
        pOpt = '-p'
    else:
        pOpt = ''

    ##############################
    # run lapw1 (-up/-dn) (-orb) #
    ##############################
    if runLAPW:
        rmerror('lapw1') # rm error files
        if spCalc or soCalc or orbCalc: # spin polarized mode
            # SOC calculation needs a faked SP (for w2w reasons)
            spOptions = ['-up', '-dn']
            if sp_cCalc: # constrained (non-magneric SP up=dn)
                spOptions = ['-up']
        else: # regular (non-spin polarized calc.)
            spOptions = ' ' # need space here!
        for suffix in spOptions:
            suffix = suffix + ' ' + pOpt # take care of parallel mode
            if orbCalc:
                suffix = suffix + ' ' + '-orb' # activate OP switch
            shell_x_lapw1 = b_PySubProcess.VirtualShellInstance(
                'x', 'lapw1', suffix
                );

            try:
                shell_x_lapw1()
            except subprocess.CalledProcessError as err:
                print(DEFAULT_PREFIX + "ERROR: in automation of " + str(structureName))
                print(DEFAULT_PREFIX + "ERROR --> " + shell_x_lapw1.getCommandString())
                print(str(err))
                return False
        testerror('lapw1') # test for non-empty error files
    else:
        print(DEFAULT_PREFIX + "Skipping 'x lapw1'")


    ###########################
    # run lapwso (-up) (-orb) #
    ###########################
    if soCalc and runLAPW: # spin-orbit coupling ONLY
        rmerror('lapwso') # rm error files
        suffix = '-up' # SOC calculation needs a faked SP (for w2w reasons)
        suffix = suffix + ' ' + pOpt # take care of parallel mode
        if orbCalc: # OP option
            suffix = suffix + ' ' + '-orb'

        shell_x_lapwso = b_PySubProcess.VirtualShellInstance(
            'x', 'lapwso', suffix
            )

        try:
            shell_x_lapwso()
        except subprocess.CalledProcessError as err:
            print(DEFAULT_PREFIX + "ERROR: in automation of " + \
                str(structureName))
            print(DEFAULT_PREFIX + "ERROR --> " + \
                shell_x_lapwso.getCommandString())
            print(str(err))
            return False
        testerror('lapwso') # test for non-empty error files

    #############################################
    # run lapw2 -fermi -in1orig (-so) (-up/-dn) #
    #############################################
    # the purpose is to generate case.scf2 file that contains band occupancies
    # (-orb) is not required here as per Laurence Marks suggestion (Sep 2020)
    # (-in1orig) is added to prevent LAPW2 from midifying case.in1(c) file.
    #            Otherwise the electronic polarization results will be slightly
    #            different for consequitive runs of BerryPI as per Laurence Marks
    #            and Peter Blaha suggestion (Sep 2020)
    if not wCalc and bands == []:
        # do not run LAPW2 with pre-set band range
        # also not in the case of Weyl point analysys/Wilson loop
        rmerror('lapw2') # rm error files
        if spCalc or soCalc or orbCalc: # spin polarized mode
            # SOC calculation needs a faked SP (for w2w reasons)
            spOptions = ['-up', '-dn']
            if sp_cCalc: # constrained (non-magneric SP up=dn)
                spOptions = ['-up']
                # cp case.energyup* case.energydn* (needed for LAPW2 -up)
                # for f in lambda1.energyup*; do cp "$f" "$(sed 's/\(.*\)up/\1dn/' <<< "$f")"; done
                shell_copy = \
                    b_PySubProcess.VirtualShellInstance(
                    "for f in",
                    str(structureName) + '.energyup*;',
                    'do cp "' + "$f" + '" "$(sed ' + "'s/\(.*\)up/\\1dn/' " +\
                         '<<< "$f")"; done',
                    )
                try:
                    shell_copy()
                except subprocess.CalledProcessError as err:
                    print(DEFAULT_PREFIX + "ERROR: in automation of " + \
                        str(structureName))
                    print(DEFAULT_PREFIX + "ERROR --> " + \
                        shell_copy.getCommandString())
                    print(str(err))
                    return False
        else: # regular (non-spin polarized calc. or SOC)
            spOptions = ' ' # need space here!
        for suffix in spOptions:
            suffix = suffix + ' ' + pOpt # take care of parallel mode
            if soCalc: # SOC
                suffix = suffix + ' ' + '-so'
            shell_x_lapw1 = b_PySubProcess.VirtualShellInstance(
                'x', 'lapw2 -fermi -in1orig', suffix
                );

            try:
                shell_x_lapw1()
            except subprocess.CalledProcessError as err:
                print(DEFAULT_PREFIX + "ERROR: in automation of " + \
                    str(structureName))
                print(DEFAULT_PREFIX + "ERROR --> " + \
                    shell_x_lapw1.getCommandString())
                print(str(err))
                return False
        testerror('lapw2') # test for non-empty error files


    #############################################
    # Calculation to get the occupied blochBand #
    #############################################
    if bands == []: # band range is not specified
        if spCalc or soCalc or orbCalc: # spin polarized mode
            print(DEFAULT_PREFIX + "Determine number of bloch bands " + \
                "in spin-polarized mode based on *.scf2(up/dn)")
            spinList = ['up', 'dn']
            if sp_cCalc: # constrained (non-magneric SP up=dn)
                # it is not a typo (there is no case.scfdn file in this case)
                spinList = ['up', 'up']
            blochBandSettings = [] # allocate array for the range of bands
            for spin in spinList: # loop over spins
                print(DEFAULT_PREFIX + " "*2 + "spin = " + spin)
                try:
                    blochBandCalculation = \
                        b_PyCalc.CalculateNumberOfBands(structureName + \
                        '.scf2' + spin);
                except b_PyError.ParseError as err:
                    print(DEFAULT_PREFIX + "ERROR: in automation of " + \
                        str(structureName))
                    print(DEFAULT_PREFIX + str(err))
                    print(DEFAULT_PREFIX + "ERROR: missing tags: " + \
                        str(err.errorTags))
                    return False
                blochBandRange = [ 1 , \
                    int(blochBandCalculation.getNumberOfBands(spCalc,soCalc, \
                    orbCalc,wCalc)) ];
                print(DEFAULT_PREFIX + " "*4 + \
                    "Number of bloch bands is {}".format(blochBandRange))
                blochBandSettings.append(blochBandRange)
        else: # regular (non-spin polarized calc.)
            print(DEFAULT_PREFIX + \
                "Determine number of bloch bands in non-sp mode")
            try:
                blochBandCalculation = \
                    b_PyCalc.CalculateNumberOfBands(structureName + '.scf2');
                # it is better to take *.scf2 file instead of
            except b_PyError.ParseError as err:
                print(DEFAULT_PREFIX + "ERROR: in automation of " + \
                    str(structureName))
                print(DEFAULT_PREFIX + str(err))
                print(DEFAULT_PREFIX + "ERROR: missing tags: " + \
                    str(err.errorTags))
                return False
            blochBandSettings = [[ 1, \
                int(blochBandCalculation.getNumberOfBands(spCalc,soCalc, \
                orbCalc,wCalc)) ]];
            print(DEFAULT_PREFIX + " "*4 + \
                "Number of bloch bands is {}".format(blochBandSettings))
    else: # the band range is specified
        blochBandSettings = []
        blochBandSettings.append(configFile['Bloch Band'])
        if spCalc or soCalc or orbCalc: # spin polarized mode
            # append the same band range again for the 2nd spin chanel
            blochBandSettings.append(configFile['Bloch Band'])

   
    ###########################################
    # allocate an array for storing the pases #
    ###########################################
    if spCalc and not soCalc: # inludes -sp; -sp -orb, but not -so, -sp -so
        nkpt = numKDivisions[1]*numKDivisions[2]
        phaseX = numpy.zeros((2,nkpt,2)) # spin (up/dn), kpoint-path-start, phase
        nkpt = numKDivisions[0]*numKDivisions[2]
        phaseY = numpy.zeros((2,nkpt,2))
        nkpt = numKDivisions[0]*numKDivisions[1]
        phaseZ = numpy.zeros((2,nkpt,2))
    else: # non-spin polarized calc. or -so or -sp -so
        nkpt = numKDivisions[1]*numKDivisions[2]
        phaseX = numpy.zeros((1,nkpt,2)) # spin degenerate(1), kpoint-path-start, phase
        nkpt = numKDivisions[0]*numKDivisions[2]
        phaseY = numpy.zeros((1,nkpt,2))
        nkpt = numKDivisions[0]*numKDivisions[1]
        phaseZ = numpy.zeros((1,nkpt,2))

    ##############################################
    # THIS IS THE MAIN LOOP OVER SPINS AND BANDS #
    ##############################################
    # Prepare spin lables even for non-sp calculation
    if spCalc or soCalc or orbCalc: # spin-polar. calculation or -so
        spinIndexes = [0, 1] # 0 - up, 1 - dn
        spinLables = ["up", "dn"]
        spinOptions = ["-up", "-dn"]
        spOption = "-sp"
        if sp_cCalc: # constrained (non-magneric SP up=dn)
            spinIndexes = [0] # 0 - up (dn=up)
            spinLables = ["up"]
            spinOptions = ["-up"]
            spOption = "-sp"
    else:# regular (non-spin polarized calc.)
        spinIndexes = [0]
        spinLables = [""] # use empty; brackets [] are for zip()
        spinOptions = [""]
        spOption = ""
    args = zip(spinIndexes, spinLables, spinOptions)
    for spinIndex, spinLable, spinOption in args: # LOOP OVER SPINS

        ####################################
        # create input list for write_inwf #
        ####################################
        if bands != [] and wCalc: # range of bands is specified
            inputListing = '-mode MMN -bands ' + str(bands[0]) + ' ' +\
                 str(bands[1])
        else: # no range of bands is specified (default)
            nb = blochBandSettings[spinIndex][1] # last occupied band
            inputListing = '-mode MMN -bands 1 ' + str(nb)


        ######################
        # execute write_inwf #
        ######################
        exe = 'write_inwf'
        shell_write_inwf = b_PySubProcess.VirtualShellInstance(
            pypath,
            w2kpath + '/' + exe,
            inputListing,
            )
        try:
            shell_write_inwf.run()
        except subprocess.CalledProcessError as err:
            print(DEFAULT_PREFIX + "ERROR: in automation of " + \
                str(structureName))
            print(DEFAULT_PREFIX + "ERROR --> " + \
                shell_write_inwf.getCommandString())
            print(str(err))
            return False

        ##################################
        # execute write_win -band nofile #
        ##################################
        exe = 'write_win -band nofile'
        shell_write_win = b_PySubProcess.VirtualShellInstance(
            exe,
            )
        case = str(structureName)
        fnameold = case + '.win'
        if os.path.isfile(fnameold): # remove old case.win if present
            print(DEFAULT_PREFIX, fnameold, 'is present and will be removed')
            os.remove(fnameold)
            if not os.path.isfile(fnameold):
                print('             ... done')
            else:
                print(DEFAULT_PREFIX, 'unable to remove', fnameold)
                print('             will continue at your own risk, w2w may crash')
        try:
            shell_write_win()
        except subprocess.CalledProcessError as err:
            print(DEFAULT_PREFIX + "ERROR: in automation of " + str(structureName))
            print(DEFAULT_PREFIX + "ERROR --> " + shell_write_win.getCommandString())
            print(str(err))
            return False
        if not spinLable == "": # for spin-polarized calc.
            fnamenew = fnameold + spinLable
            shutil.copy(fnameold, fnamenew) # copy case.win to case.win[up/dn]

        ######################################
        # move case.inwf -> case.inwf[up/dn] #
        ######################################
        if not spinLable == "": # for spin-polarized calc.
            case = str(structureName)
            fnameold = case + '.inwf'
            fnamenew = fnameold + spinLable
            print(DEFAULT_PREFIX + "Move " + fnameold + " into " + fnamenew)
            shutil.move(fnameold, fnamenew) # move case.inwf to case.inwf[up/dn] 


        #######################
        # execute win2nnkp.py #
        #######################
        if wCalc:
            wOption = '-w'
        else:
            wOption = ''
        shell_win2nnkp = b_PySubProcess.VirtualShellInstance(
                pypath,
                bppath + '/' + 'win2nnkp.py',
                str(structureName), wOption,
                )
        try:
            shell_win2nnkp()
        except subprocess.CalledProcessError as err:
            print(DEFAULT_PREFIX + "ERROR: in automation of " + \
                  str(structureName) + suffix)
            print(DEFAULT_PREFIX + "ERROR --> " + \
                  shell_win2nnkp.getCommandString())
            print(str(err))
            return False


        #####################
        # create case.fermi #
        #####################
        case = str(structureName)
        fname = case + '.fermi' + spinLable # write Fermi energy to case.fermi file
        if os.path.isfile(fname): # remove old case.fermi if present
            print(DEFAULT_PREFIX, fname, 'is present and will be removed')
            os.remove(fname)
            if not os.path.isfile(fname):
                print('             ... done')
            else:
                print(DEFAULT_PREFIX, 'unable to remove', fname)
                print('             will continue at your own risk')
        file = open(fname, "w")
        # write Ef = 0. The value makes no difference for w2w (only file with 
        # a value should be present). The value is important only for a Wannier
        # interpolated band structure plot.
        file.write("0.0" + '\n') # add end of line
        file.close()
        print(DEFAULT_PREFIX + 'Fermi energy file', fname, 'created')


        ###############
        # execute w2w #
        ###############
        suffix = pOpt # take care of parallel mode
        rmerror('w2w') # rm error files
        if soCalc: # for spin-orbit call executables directly
            shell_w2w = b_PySubProcess.VirtualShellInstance( \
                'x w2w -so', spinOption, suffix );
        else:
            shell_w2w = b_PySubProcess.VirtualShellInstance( \
                'x w2w', spinOption, suffix );
        try:
            shell_w2w()
        except subprocess.CalledProcessError as err:
            print(DEFAULT_PREFIX + "ERROR: in automation of " + str(structureName))
            print(DEFAULT_PREFIX + "ERROR --> " + shell_w2w.getCommandString())
            print(str(err))
            return False
        testerror('w2w') # test for non-empty error files


        ####################
        # execute w2waddsp #
        ####################
        if soCalc and spinLable=='dn': # spin-orbit last passage
            shell_csf = b_PySubProcess.VirtualShellInstance( \
                'x w2waddsp' );
            try:
                shell_csf()
            except subprocess.CalledProcessError as err:
                print(DEFAULT_PREFIX + "ERROR: in automation of " + str(structureName))
                print(DEFAULT_PREFIX + "ERROR --> " + shell_csf.getCommandString())
                print(str(err))
                return False
        

        ######################################################
        # Compute Berry phase:                               #
        # python ./mmn2pathphase.py case x/y/z (-up/-dn/-so) #
        ######################################################
        if soCalc and spinLable=='up':
            pass # spin-orbit skip first passage
        else:
            if soCalc:
                spinIndex = 0 # reset counter for proper writing below
            directions = ['x', 'y', 'z']
            for direction in directions:
                if not soCalc:
                    opt = spinOption
                else:
                    opt = '-so' # work around for spin-orbit
                if wCalc:
                    opt = opt + ' ' + '-w'
                args = [str(structureName), direction, opt]
                pathPhases = mmn2pathphase.main(args)
                if wCalc:
                    break
                if   direction == 'x':
                    phaseX[spinIndex,:,:] = pathPhases
                elif direction == 'y':
                    phaseY[spinIndex,:,:] = pathPhases
                elif direction == 'z':
                    phaseZ[spinIndex,:,:] = pathPhases
                if sp_cCalc: # constrained non-magnetic SP (up=dn)
                    # copy results up=dn
                    phaseX[spinIndex+1,:,:] = phaseX[spinIndex,:,:]
                    phaseY[spinIndex+1,:,:] = phaseY[spinIndex,:,:]
                    phaseZ[spinIndex+1,:,:] = phaseZ[spinIndex,:,:]

    # END OF THE MAIN LOOP FOR BERRY PHASE CALCULATION+++++++++++++++++++
    
    results = [phaseX,phaseY,phaseZ]

    ####################################################################
    # Clean up files intended to fake SP calculation if SO coupling is #
    # activated without spin polarization                              #
    # rm $filename.vsp[up/dn]                                          #
    # rm $filename.vns[up/dn]                                          #
    #                                                                  #
    # In case of constrained spin-polarized calculation                #
    # rm case.energydn*                                                #
    ####################################################################
    if soCalc and not spCalc:
        print(DEFAULT_PREFIX + "Removing duplicated files...")
        for ext in ['.vsp', '.vns']:
            for spin in ['up', 'dn']:
                shell_pathphase_y_rm = \
                    b_PySubProcess.VirtualShellInstance(
                    'rm',
                    str(structureName) + ext + spin,
                    );
                try:
                    shell_pathphase_y_rm()
                except subprocess.CalledProcessError as err:
                    print(DEFAULT_PREFIX + "ERROR: in automation of " + \
                        str(structureName))
                    print(DEFAULT_PREFIX + "ERROR --> " + \
                        shell_pathphase_y_rm.getCommandString())
                    print(str(err))
                    return False
    elif sp_cCalc: # rm case.energydn (created for LAPW2 -up)
        print(DEFAULT_PREFIX + "Removing duplicated files...")
        shell_copy = \
            b_PySubProcess.VirtualShellInstance(
            'rm',
            str(structureName) + '.energydn*',
            )
        try:
            shell_copy()
        except subprocess.CalledProcessError as err:
            print(DEFAULT_PREFIX + "ERROR: in automation of " + \
                str(structureName))
            print(DEFAULT_PREFIX + "ERROR --> " + \
                shell_copy.getCommandString())
            print(str(err))
            return False

    print(DEFAULT_PREFIX + "Finished Berry phase computation for " + \
        structureName)

    return [True,results]
# END rawBerryPhase


if __name__ == "__main__":
    def helpInfo():
        print('''

        DEPENDENCIES:
        - WIEN2k + WIEN2WANNIER (tested against v17.1)
        - Python (tested against 2.7.1)
        - NumPy (tested against 1.12.0)

        Once you have all the dependencies installed.
        To run "BerryPI" after standard WIEN2k scf cycle run the following command

        berrypi -k NUM:NUM:NUM [+options see below]

        OPTIONS:

        -h

        Print this help

        --kdiv=NUM:NUM:NUM, -kNUM:NUM:NUM

        Determines the k-mesh for sampling the BZ

        Additional Switches:

        --spin-polarization, -s

        Activate spin polarized caclulation
        
        --sp_c
        
        Constrained spin-polarized calculation (non-magnetic, up=dn)

        --orb-potential, -o

        Activate calculation with an additional orbit potential
        (e.g., LSDA+U)

        --spin-orbit, -j

        Activate spin orbit coupling

        --bloch-band=NUM:NUM, -b NUM:NUM

        Used to manually set the bloch band for band by band decomposition.
        By default, it is parsing out the bloch band based on the number
        of total bands.

        -l

        Skip lapw1 run. It assumes that the electronic phase calculation
        has been performed before and all the required files are for
        computaion of polarization is present and it just calculate the
        polarization based on those data. In this case the k-mesh will be
        read from case.klist file

        -p

        Enable parallel caulculation where it run "x lapw1 -p", "x lapwso -p"
        and "x w2w -p" in parallel mode. It implies that you have .machines file
        prepared accorning to Wien2k documentation

        -w

        Compute Berry phase along a specific k-path given in the case.klist file.
        It is used to characterize Weyl-points. This option must be combined 
        with (-b XX:YY) to specify the band range and (-j) to enable spin-orbit 
        coupling.


        EXAMPLES:

        Run non spin-polarized calculation with 6x6x4 k-mesh

        $ berrypi -k6:6:4

        Subsequent rerun of BerryPI in the same folder without 
        changing k-mesh (skipping LAPW1)

        $ berrypi -l

        Spin-polarized calculation

        $ berrypi -s -k6:6:4
        
        Spin-polarized constrained calculation (up=dn, non-magnetic)
        
        $ berrypi --sp_c -k6:6:4

        Spin-polarized calculation with spin-orbit coupling

        $ berrypi -s -j -k6:6:4

        Spin-polarized calculation with an additional orbital potential 
        (no need for -s option since it is implicitly assumed)

        $ berrypi -o -k6:6:4

        Compute Berry phase along a specific k-path (loop) given in 
        the case.klist file. It is used to characterize Weyl-points.

        $ berrypi -j -w -b XX:YY

        Enable parallel calculation where it run x lapw1 -p, x lapwso -p 
        and x w2w -p in parallel mode. It implies that you have .machines 
        file prepared according to Wien2k documentation

        $ berrypi -p -k6:6:4
        ''')
        pass

        
    try:
        opts, args = getopt.getopt(sys.argv[1:], \
            "S:hvpnk:lb:sojw", \
            ["help", "structure-name=", \
            "bloch-band=", "spin-polarized", "sp_c", "no-auto", "kdiv=", "no-lapw1", \
            "parallel", "verbose", "orb-potential", "spin-orbit"]);
    except getopt.GetoptError as err:
        # print help information and exit:
        print(helpInfo())
        print("ERROR")
        print(str(err)) # will print something like "option -a not recognized"
        sys.exit(2)

    #boolean for whether to check config for
    #configuration dicts
    checkConfig = True

    #boolean for whether to automate the entire process
    checkAuto = True

    #defaults
    structure_name = ''
    structure_path = ''
    structure_kmesh = config.DEFAULT_KMESH_DIVISIONS
    bands = []
    runLAPW = True
    VERBOSE = False

    helpOpt = False
    pCalc = False   # calculation is serial by defaul
    spCalc = False  # no spin polarization by default
    orbCalc = False # no additional orbital potential by default
    soCalc = False  # no spin-orbit coupling by default
    wCalc = False # no k-path specified by default
    sp_cCalc = False # no constrained spin-polarized by default
    
    # Set default case name and path based on where berrypi is executed
    structure_path = os.getcwd()
    structure_name = os.path.split(os.getcwd())[-1]
    
    # redirect stdout to case.outputberry file and console
    # case mane is taken from structure_name
    sys.stdout = Logger()

    #begin checking command line arguments
    for argName, argValue in opts:

        #help option
        if argName in ("-h", "--help"):
            print(helpInfo())
            helpOpt = True
            sys.exit(0)

        #structure name option
        elif argName in ('-S', '--structure-name'):
            structure_name = argValue

        #enable spin polarization
        elif argName in ('-s', '--spin-polarized'):
            print(DEFAULT_PREFIX+'Spin polarization is activated')
            spCalc = True

        #enable constrained (non-magnetic) spin polarization
        elif argName in ('--sp_c'):
            print(DEFAULT_PREFIX+'Constrained (non-magnetic) ' +\
                'spin polarization is activated')
            spCalc = True
            sp_cCalc = True

        #enable orbital potential
        elif argName in ('-o', '--orb-potential'):
            print(DEFAULT_PREFIX+'Calculation with an additional '+ \
                'orbital potential is activated');
            orbCalc = True
            print(DEFAULT_PREFIX+'Spin polarization is activated '+ \
                'automatically with adding orbital potential')
            spCalc = True

        #enable spin orbit coupling
        elif argName in ('-j', '--spin-orbit'): # [OLEG] here
            print(DEFAULT_PREFIX+'Calculation with spin-orbit '+ \
                'coupling is activated');
            soCalc = True # OR add combination of "--sp_c -j"

        #automation disabling option
        elif argName in ('-n', '--no-auto'):
            checkAuto = False

        # k-mesh
        elif argName in ('-k', '--kdiv'):
            try: structure_kmesh = [ int(i) for i in argValue.split(':') ] 
            except ValueError:
                print('Value Error: Please enter the integers '+\
                    'into kmesh in the format of "-k NX:NY:NZ"');
                sys.exit(2)      

        #Determines whether you should include lapw1 in the automation
        elif argName in ('-l', '--no-lapw'):
            runLAPW = False

        #Determines whether to run lapw1 in parallel on the clustrer
        elif argName in ('-p', '--parallel'):
            print(DEFAULT_PREFIX+"Parallel calculation is activated")
            print("            it is assumed that you have .machines file ready")
            pCalc = True # turn to True when implementation finished

        elif argName in ('-b', '--bloch-band'):
            print(DEFAULT_PREFIX+"Only selected range of bands will be used ")
            bands = [ int(i) for i in argValue.split(':') ]
            print(DEFAULT_PREFIX, "bands=", bands)

        elif argName in ('-w'):
            print(DEFAULT_PREFIX+"Enable Berry phase calculation along a "+\
                "specific k-path given in the case.klist file. ")
            print(DEFAULT_PREFIX+"Any input of the k-mesh (-k ... option) "+\
                "will be ignored")
            wCalc = True

        elif argName in ('-v', '--verbose'):
            VERBOSE = True
        else:
            print("Invalid argument {} - {}").format(argName, argValue)
            sys.exit(2)

    if not helpOpt and checkAuto:
        try:
            structure_kmesh # check if k-mesh defined in input param.
        except NameError: # k-mesh is not defined, ask for input
            k_mesh_values=raw_input('What kmesh values would you like? '+ \
                '(e.g. 2:2:2)\n');
            try: structure_kmesh = [ int(i) for i in k_mesh_values.split(':') ] 
            except ValueError:
                print('Value Error: Please enter the integers into '+ \
                    'kmesh in the format of "x:x:x"');
                sys.exit(2)
        else:
            if not wCalc:
                print(DEFAULT_PREFIX+'Proceed with the k-mesh', \
                    structure_kmesh)

    # Check input consistency
    if len(structure_kmesh)!=3:
        #Makes sure that the k-mesh length of the tuple is 3
        print('You entered: ' +str(structure_kmesh))
        print('ERROR: Please check that you have 3 integers in the kmesh')
        sys.exit(2)
    elif 0 in structure_kmesh:
        #Makes sure that there are no values of 0 in the kmesh
        print('You entered: ' + str(structure_kmesh))
        print('ERROR: Cannot have a dimension of 0 in the kmesh')
        sys.exit(2)
    elif min(structure_kmesh)<0:
        #Sets the lower bound of the dimensions
        print('ERROR: You cannot have negative integers as kmesh values')
        sys.exit(2)
    elif wCalc and not soCalc:
        #Wilson loop calculation makes sense with SOC only
        print('WARNING: Wilson loop calculation makes sense only if',\
            'combined with spin-orbit coupling (-j)')
        print('Suggested execution: berrypi -j -w -b XX:YY')
        print('Calculation will continue')
    elif wCalc and bands == []:
        #Band range is not specified for Wilson loop calculation
        print('ERROR: Wilson loop calculatio requires the band range',\
            'to be specified')
        print('Suggested execution: berrypi -j -w -b XX:YY')
        sys.exit(2)
    if bands != [] and len(bands)!=2:
        #Makes sure that the band range length of the tuple is 2
        print('You entered: ' + str(bands))
        print('ERROR: Please check that you have 2 integers in the band range')
        sys.exit(2)
    elif bands != [] and 0 in bands:
        #Makes sure that there are no values of 0 in the bands
        print('You entered: ' + str(bands))
        print('ERROR: Cannot have a dimension of 0 in the bands range')
        sys.exit(2)
    elif bands != [] and min(bands)<0:
        #Sets the lower bound of the dimensions
        print('You entered: ' + str(bands))
        print('ERROR: You cannot have negative integers as bands range values')
        sys.exit(2)
    elif bands != [] and bands[0] > bands[1]:
        #The range of bands should start with a smaller value
        print('You entered: ' + str(bands))
        print('ERROR: The range of bands should start with a smaller value')
        sys.exit(2)
            
    #Determines whether or not W2WANNIER is installed
    wienroot = os.getenv('WIENROOT') # get path to Wien2k installation
    try:
        with open(wienroot + '/w2w'): pass
    except IOError:
        print('Please make sure that W2W is installed before trying to run BerryPI')
        
    #if configuration values are provided, create config file to pass
    #to the automation and calculations
    if structure_name or structure_path:
        if structure_name and structure_path:
            #follows same format as config.py configurations
            configFile = {
                'Structure Name' : structure_name,
                'Structure Path' : structure_path,
                'Number of K-Points' : config.DEFAULT_NUMBER_OF_KPOINTS,
                'K-Mesh Divisions' : structure_kmesh,
                'K-Mesh Shift' : config.DEFAULT_KMESH_SHIFT, 
                'Bloch Band' : bands,
                'Number of Wannier Functions' : config.DEFAULT_WANNIER_FUNCTIONS,
                'Center Atom and Character' : config.DEFAULT_CENTER_ATOM_AND_CHARACTER,
                'Perform LAPW' : runLAPW,
                'Parallel mode' : pCalc,
                'Spin polarized calculation' : spCalc,
                'Add orbital potential' : orbCalc,
                'Spin-orbit coupling' : soCalc,
                }
            checkConfig = False
        else:
            print("structure name and structure path must be provided")
            raise getopt.GetoptError

    #check config (based on if structure name or
    #structure path has been passed to berryPyRunAutomation.py)
    bAutomationErrorChk = True
    if checkConfig:
        ConfigurationFiles = config.berryPyConfigAutomationList
        for berryConfig in ConfigurationFiles:
            #check whether to automate
            if checkAuto:
                bAutomationErrorChk = rawBerryPhase(berryConfig)
            if bAutomationErrorChk and not wCalc:
                try:
                    theCalc = postProcBerryPhase(berryConfig)
                except b_PyError.ParseError as err:
                    print(DEFAULT_PREFIX + "ERROR: in automation of " + \
                        berryConfig['Structure Name'])
                    print(DEFAULT_PREFIX + str(err))
                    print(DEFAULT_PREFIX + "ERROR: missing tags: " + \
                        str(err.errorTags))
                    continue
                #write to file
                writeResult(berryConfig, theCalc)
    else:
        #assuming the configFile was passed correctly
        if checkAuto:
            [bAutomationErrorChk,phasesRaw] = rawBerryPhase(configFile)
        if bAutomationErrorChk and not wCalc:
            try:
                theCalc = postProcBerryPhase(configFile,phasesRaw,spCalc)
            except b_PyError.ParseError as err:
                print(DEFAULT_PREFIX + "ERROR: in automation of " + \
                    configFile['Structure Name'])
                print(DEFAULT_PREFIX + str(err))
                print(DEFAULT_PREFIX + "ERROR: missing tags: " + \
                    str(err.errorTags))
    
    
    # Final remarks
    w2kpath = os.getenv('WIENROOT') # get path to WIEN2k
    # open version file
    with open(w2kpath+'/SRC_BerryPI/BerryPI/version.info', 'r') as versionFile:
        print("\nCompleted using BerryPI version:", versionFile.read())
    print('''
Suggested reference:
    S.J.Ahmed, J.Kivinen, B.Zaporzan, L.Curiel, S.Pichardo and O.Rubel
    Comp. Phys. Commun. 184, 647 (2013)

Questions and comments are to be directed to
    Dr. Oleg Rubel
    Department of Material Science and Engineering
    McMaster University
    1280 Main Street West, Hamilton, ON Canada L8S 4L8
    Tel: +1-905-5259140, ext. 24094
    E-mail: rubelo@mcmaster.ca
    URL: http://olegrubel.mcmaster.ca
or
    Dr. Samuel Pichardo 
    Lakehead University
          and
    Sunnybrook Health Science Centre
    2075 Bayview Avenue, Toronto, ON Canada M4N 3M5 
    Tel: +1 (416) 480-6156
    E-mail: spichard@lakeheadu.ca
    URL: http://www.proteus-mrighifu.net''')
